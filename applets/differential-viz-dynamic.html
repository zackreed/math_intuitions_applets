<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dynamic Differential Visualization</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #0a0e27; color: #eee; display: flex; gap: 20px; min-height: 100vh; }
        canvas { border: 2px solid #4a5568; background: #16213e; box-shadow: 0 4px 6px rgba(0,0,0,0.3); cursor: crosshair; }
        #controls { width: 300px; background: #0f3460; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); overflow-y: auto; max-height: 90vh; }
        h2 { margin-top: 0; color: #e94560; border-bottom: 2px solid #e94560; padding-bottom: 10px; }
        h3 { color: #4ecca3; font-size: 16px; margin-top: 20px; }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; color: #4ecca3; font-size: 14px; }
        input[type="text"], input[type="number"] { width: 100%; padding: 8px; background: #16213e; border: 1px solid #4a5568; border-radius: 4px; color: #eee; font-size: 14px; box-sizing: border-box; margin-bottom: 5px; }
        button { width: 100%; padding: 12px; background: #4ecca3; color: #0a0e27; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; margin: 5px 0; transition: all 0.3s; }
        button:hover { background: #3db894; transform: translateY(-2px); }
        .info-box { background: #16213e; padding: 15px; border-radius: 4px; margin-top: 10px; font-size: 14px; line-height: 1.6; }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
        input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
        .error { background: #8b0000; color: #fff; padding: 10px; border-radius: 4px; margin-top: 10px; }
    </style>
</head>
<body>
    <div><canvas id="canvas" width="700" height="600"></canvas></div>
    <div id="controls">
        <h2>Dynamic Differential Viz</h2>
        <div class="control-group">
            <label>Function y =</label>
            <input type="text" id="func" value="x^2">
            <label>x min:</label>
            <input type="number" id="xmin" value="0" step="0.5">
            <label>x max:</label>
            <input type="number" id="xmax" value="6" step="0.5">
            <button id="update">Update Function</button>
            <div id="error"></div>
        </div>
        <div class="info-box"><strong>Instructions:</strong><br>• Enter function and domain<br>• Drag red point to explore<br>• Zoom shows differentials<br>• Stacked vectors show derivative</div>
    </div>
    <script>
const c=document.getElementById('canvas'),ctx=c.getContext('2d');
let px=3.5,drag=false;
let showT=true,showD=true,showV=true; // Always true, no toggles
let fs='x^2',f=x=>x*x,xMin=0,xMax=6,yMin=-1,yMax=12;
let legP={x:50,y:20},zoomP={x:405,y:15};
const pad=50,w=c.width-2*pad,h=c.height-2*pad;

function parse(s){
 try{
  s=s.replace(/\^/g,'**').replace(/(\d)([a-z])/gi,'$1*$2');
  s=s.replace(/sin/g,'Math.sin').replace(/cos/g,'Math.cos').replace(/tan/g,'Math.tan');
  s=s.replace(/sqrt/g,'Math.sqrt').replace(/exp/g,'Math.exp').replace(/log/g,'Math.log').replace(/abs/g,'Math.abs');
  const fn=new Function('x',`return ${s};`);
  fn(1);
  return fn;
 }catch(e){return null;}
}

function calcY(){
 let yMn=Infinity,yMx=-Infinity;
 for(let x=xMin;x<=xMax;x+=(xMax-xMin)/100){
  try{
   const y=f(x);
   if(!isNaN(y)&&isFinite(y)){yMn=Math.min(yMn,y);yMx=Math.max(yMx,y);}
  }catch(e){}
 }
 const r=yMx-yMn;
 if(!isFinite(r)||r>1000||r<0.001)return false;
 const p=r*0.15;
 yMin=yMn-p;yMax=yMx+p;
 return true;
}

function calcPos(){
 const cov=[0,0,0,0];
 for(let x=xMin;x<=xMax;x+=(xMax-xMin)/50){
  try{
   const y=f(x);
   if(!isNaN(y)&&isFinite(y)&&y>=yMin&&y<=yMax){
    const [cx,cy]=toC(x,y);
    const isL=cx<c.width/2,isT=cy<c.height/2;
    if(isL&&isT)cov[0]++;
    else if(!isL&&isT)cov[1]++;
    else if(isL&&!isT)cov[2]++;
    else cov[3]++;
   }
  }catch(e){}
 }
 const s=cov.map((ct,i)=>({ct,i})).sort((a,b)=>a.ct-b.ct);
 legP=getQ(s[0].i,240,105);
 zoomP=getQ(s[1].i,280,220);
}

function getQ(q,w,h){
 const p=15;
 switch(q){
  case 0:return{x:pad-5,y:pad-30};
  case 1:return{x:c.width-w-p,y:p};
  case 2:return{x:pad-5,y:c.height-h-p};
  case 3:return{x:c.width-w-p,y:c.height-h-p};
 }
}

function deriv(x){return(f(x+0.0001)-f(x-0.0001))/0.0002;}

function toC(x,y){return[pad+((x-xMin)/(xMax-xMin))*w,pad+h-((y-yMin)/(yMax-yMin))*h];}
function toM(cx,cy){return[xMin+((cx-pad)/w)*(xMax-xMin),yMin+((pad+h-cy)/h)*(yMax-yMin)];}
function toZ(x,y,cx,cy,s){return[zoomP.x+280*0.25+(x-cx)*s,zoomP.y+110-(y-cy)*s];}

function draw(){
 ctx.clearRect(0,0,c.width,c.height);
 // Axes
 ctx.strokeStyle='#4a5568';ctx.lineWidth=2;
 const [x1,y1]=toC(xMin,0),[x2,y2]=toC(xMax,0);
 ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();
 const [x3,y3]=toC(0,yMin),[x4,y4]=toC(0,yMax);
 ctx.beginPath();ctx.moveTo(x3,y3);ctx.lineTo(x4,y4);ctx.stroke();
 
 // Grid
 ctx.strokeStyle='#2d3748';ctx.lineWidth=1;ctx.setLineDash([2,2]);
 for(let x=Math.ceil(xMin);x<=Math.floor(xMax);x++){
  const [c1,cy1]=toC(x,yMin),[c2,cy2]=toC(x,yMax);
  ctx.beginPath();ctx.moveTo(c1,cy1);ctx.lineTo(c2,cy2);ctx.stroke();
 }
 ctx.setLineDash([]);
 
 // Function
 ctx.strokeStyle='#4ecca3';ctx.lineWidth=3;ctx.beginPath();
 let start=false;
 for(let x=xMin;x<=xMax;x+=(xMax-xMin)/200){
  try{
   const y=f(x);
   if(!isNaN(y)&&isFinite(y)&&y>=yMin&&y<=yMax){
    const [cx,cy]=toC(x,y);
    if(!start){ctx.moveTo(cx,cy);start=true;}
    else ctx.lineTo(cx,cy);
   }
  }catch(e){}
 }
 ctx.stroke();
 
 // Point
 const py=f(px),[ppx,ppy]=toC(px,py);
 ctx.strokeStyle='#ffe66d';ctx.lineWidth=2;
 ctx.strokeRect(ppx-40,ppy-40,80,80);
 ctx.fillStyle='#e94560';ctx.beginPath();ctx.arc(ppx,ppy,10,0,2*Math.PI);ctx.fill();
 ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();
 
 // Coords
 ctx.font='italic 16px Georgia';
 const txt=`(${px.toFixed(2)}, ${py.toFixed(2)})`;
 ctx.fillStyle='#eee';
 const tw=ctx.measureText(txt).width;
 ctx.fillStyle='#16213e';ctx.fillRect(ppx+17,ppy+11,tw+6,20);
 let xo=ppx+20;
 ctx.fillStyle='#eee';ctx.fillText('(',xo,ppy+25);xo+=ctx.measureText('(').width;
 ctx.fillStyle='#e94560';ctx.fillText(px.toFixed(2),xo,ppy+25);xo+=ctx.measureText(px.toFixed(2)).width;
 ctx.fillStyle='#eee';ctx.fillText(', ',xo,ppy+25);xo+=ctx.measureText(', ').width;
 ctx.fillStyle='#4ecca3';ctx.fillText(py.toFixed(2),xo,ppy+25);xo+=ctx.measureText(py.toFixed(2)).width;
 ctx.fillStyle='#eee';ctx.fillText(')',xo,ppy+25);
 
 drawLegend();
 drawZoom();
}

function drawLegend(){
 const sl=deriv(px);
 ctx.fillStyle='rgba(15,52,96,0.9)';ctx.fillRect(legP.x,legP.y,240,105);
 ctx.strokeStyle='#4a5568';ctx.lineWidth=2;ctx.strokeRect(legP.x,legP.y,240,105);
 ctx.font='bold 14px Arial';ctx.fillStyle='#ffe66d';ctx.textAlign='left';
 ctx.fillText('Legend',legP.x+5,legP.y+18);
 ctx.font='italic 20px Georgia';
 let xp=legP.x+15,yp=legP.y+43;
 ctx.fillStyle='#4ecca3';ctx.fillText('y = ',xp,yp);xp+=ctx.measureText('y = ').width;
 
 // Convert function to nice math notation
 let display=fs.replace(/\*/g,'');
 display=display.replace(/sqrt\(([^)]+)\)/g,(m,p1)=>`√${p1}`);
 display=display.replace(/exp\(([^)]+)\)/g,(m,p1)=>`e^${p1}`);
 display=display.replace(/log\(([^)]+)\)/g,(m,p1)=>`ln(${p1})`);
 display=display.replace(/abs\(([^)]+)\)/g,(m,p1)=>`|${p1}|`);
 
 // Parse and render with superscripts
 const pts=display.split(/(\^)/);
 for(let i=0;i<pts.length;i++){
  if(pts[i]==='^'&&i+1<pts.length){
   let sup=pts[i+1];
   // Handle {braces} in superscripts
   if(sup.startsWith('{')){
    const end=sup.indexOf('}');
    sup=sup.substring(1,end);
    pts[i+1]=sup+pts[i+1].substring(end+1);
   }
   ctx.font='italic 14px Georgia';ctx.fillText(sup,xp,yp-8);
   xp+=ctx.measureText(sup).width;ctx.font='italic 20px Georgia';i++;
  }else if(pts[i]!=='^'&&pts[i]!==''){
   ctx.fillText(pts[i],xp,yp);xp+=ctx.measureText(pts[i]).width;
  }
 }
 
 yp=legP.y+68;xp=legP.x+15;
 ctx.fillStyle='#4ecca3';ctx.fillText('dy',xp,yp);xp+=ctx.measureText('dy').width;
 ctx.fillStyle='#eee';ctx.fillText('/',xp,yp);xp+=ctx.measureText('/').width;
 ctx.fillStyle='#ffe66d';ctx.fillText('dx',xp,yp);xp+=ctx.measureText('dx').width;
 ctx.fillStyle='#eee';ctx.fillText(' = ',xp,yp);xp+=ctx.measureText(' = ').width;
 ctx.fillStyle='#ff9d76';ctx.fillText(sl.toFixed(2),xp,yp);
 yp=legP.y+93;xp=legP.x+15;
 ctx.fillStyle='#4ecca3';ctx.fillText('dy',xp,yp);xp+=ctx.measureText('dy').width;
 ctx.fillStyle='#eee';ctx.fillText(' = ',xp,yp);xp+=ctx.measureText(' = ').width;
 ctx.fillStyle='#ff9d76';ctx.fillText(sl.toFixed(2),xp,yp);xp+=ctx.measureText(sl.toFixed(2)).width;
 ctx.fillStyle='#eee';ctx.fillText(' · ',xp,yp);xp+=ctx.measureText(' · ').width;
 ctx.fillStyle='#ffe66d';ctx.fillText('dx',xp,yp);
}

function drawZoom(){
 const cx=px,cy=f(px),sl=deriv(px);
 const dx=0.1,dy=sl*dx;
 const md=Math.max(Math.abs(dx),Math.abs(dy))*1.4;
 const sc=Math.min(280,220)/(2*md);
 ctx.save();ctx.beginPath();ctx.rect(zoomP.x,zoomP.y,280,220);ctx.clip();
 ctx.fillStyle='rgba(22,33,62,0.95)';ctx.fillRect(zoomP.x,zoomP.y,280,220);
 ctx.strokeStyle='#ffe66d';ctx.lineWidth=3;ctx.strokeRect(zoomP.x,zoomP.y,280,220);
 
 // Function
 ctx.strokeStyle='#4ecca3';ctx.lineWidth=3;ctx.beginPath();start=false;
 for(let x=cx-md;x<=cx+md;x+=md/100){
  try{
   const y=f(x);
   if(!isNaN(y)&&isFinite(y)){
    const [zx,zy]=toZ(x,y,cx,cy,sc);
    if(!start){ctx.moveTo(zx,zy);start=true;}
    else ctx.lineTo(zx,zy);
   }
  }catch(e){}
 }
 ctx.stroke();
 
 const [zpx,zpy]=toZ(cx,cy,cx,cy,sc);
 
 // Tangent - always shown
 const [tx1,ty1]=toZ(cx-md*0.9,cy+sl*(cx-md*0.9-cx),cx,cy,sc);
 const [tx2,ty2]=toZ(cx+md*0.9,cy+sl*(cx+md*0.9-cx),cx,cy,sc);
 ctx.strokeStyle='#ff9d76';ctx.lineWidth=3;ctx.setLineDash([8,4]);
 ctx.beginPath();ctx.moveTo(tx1,ty1);ctx.lineTo(tx2,ty2);ctx.stroke();
 ctx.setLineDash([]);
 
 // dx
 if(showD){
  const dxe=cx+dx;
  const [dx1,dy1]=toZ(cx,cy,cx,cy,sc),[dx2,dy2]=toZ(dxe,cy,cx,cy,sc);
  ctx.strokeStyle='#ffe66d';ctx.lineWidth=4;
  ctx.beginPath();ctx.moveTo(dx1,dy1);ctx.lineTo(dx2,dy2);ctx.stroke();
  const a1=Math.atan2(dy2-dy1,dx2-dx1),al=12;
  ctx.beginPath();ctx.moveTo(dx2,dy2);
  ctx.lineTo(dx2-al*Math.cos(a1-Math.PI/6),dy2-al*Math.sin(a1-Math.PI/6));
  ctx.lineTo(dx2-al*0.5*Math.cos(a1),dy2-al*0.5*Math.sin(a1));
  ctx.lineTo(dx2-al*Math.cos(a1+Math.PI/6),dy2-al*Math.sin(a1+Math.PI/6));
  ctx.closePath();ctx.fillStyle='#ffe66d';ctx.fill();
  const [dmx,dmy]=toZ((cx+dxe)/2,cy,cx,cy,sc);
  ctx.font='italic 18px Georgia';ctx.textAlign='center';ctx.fillText('dx',dmx,dmy+25);
  
  // Vectors
  if(showV&&Math.abs(sl)>0.1){
   const wp=Math.floor(Math.abs(sl)),fp=Math.abs(sl)-wp;
   const vsx=dxe+dx*0.15;
   let cury=cy;
   for(let i=0;i<wp;i++){
    const [vx1,vy1]=toZ(vsx,cury,cx,cy,sc),[vx2,vy2]=toZ(vsx,cury+Math.sign(sl)*dx,cx,cy,sc);
    ctx.strokeStyle='#ff9d76';ctx.lineWidth=3;
    ctx.beginPath();ctx.moveTo(vx1,vy1);ctx.lineTo(vx2,vy2);ctx.stroke();
    const va=Math.atan2(vy2-vy1,vx2-vx1),vl=10;
    ctx.beginPath();ctx.moveTo(vx2,vy2);
    ctx.lineTo(vx2-vl*Math.cos(va-Math.PI/6),vy2-vl*Math.sin(va-Math.PI/6));
    ctx.lineTo(vx2-vl*0.5*Math.cos(va),vy2-vl*0.5*Math.sin(va));
    ctx.lineTo(vx2-vl*Math.cos(va+Math.PI/6),vy2-vl*Math.sin(va+Math.PI/6));
    ctx.closePath();ctx.fillStyle='#ff9d76';ctx.fill();
    const [vmx,vmy]=toZ(vsx,cury+Math.sign(sl)*dx/2,cx,cy,sc);
    ctx.fillStyle='#ffe66d';ctx.font='italic 14px Georgia';ctx.fillText('dx',vmx+30,vmy);
    cury+=Math.sign(sl)*dx;
   }
   if(fp>0.05){
    const [vx1,vy1]=toZ(vsx,cury,cx,cy,sc),[vx2,vy2]=toZ(vsx,cury+Math.sign(sl)*fp*dx,cx,cy,sc);
    ctx.strokeStyle='#ff9d76';ctx.lineWidth=3;
    ctx.beginPath();ctx.moveTo(vx1,vy1);ctx.lineTo(vx2,vy2);ctx.stroke();
    const va=Math.atan2(vy2-vy1,vx2-vx1),vl=10;
    ctx.beginPath();ctx.moveTo(vx2,vy2);
    ctx.lineTo(vx2-vl*Math.cos(va-Math.PI/6),vy2-vl*Math.sin(va-Math.PI/6));
    ctx.lineTo(vx2-vl*0.5*Math.cos(va),vy2-vl*0.5*Math.sin(va));
    ctx.lineTo(vx2-vl*Math.cos(va+Math.PI/6),vy2-vl*Math.sin(va+Math.PI/6));
    ctx.closePath();ctx.fillStyle='#ff9d76';ctx.fill();
    const [vmx,vmy]=toZ(vsx,cury+Math.sign(sl)*fp*dx/2,cx,cy,sc);
    ctx.font='italic 12px Georgia';
    ctx.fillStyle='#ff9d76';ctx.fillText(fp.toFixed(2),vmx+30,vmy);
    ctx.fillStyle='#ffe66d';ctx.fillText(' dx',vmx+45,vmy);
   }
  }
 }
 
 ctx.fillStyle='#e94560';ctx.beginPath();ctx.arc(zpx,zpy,9,0,2*Math.PI);ctx.fill();
 ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();
 ctx.font='bold 14px Arial';ctx.fillStyle='#ffe66d';ctx.textAlign='center';
 ctx.fillText('Zoomed View',zoomP.x+140,zoomP.y+18);
 ctx.restore();
}

function upd(){
 // Function removed - derivative display removed
}

c.addEventListener('mousedown',e=>{
 const r=c.getBoundingClientRect(),mx=e.clientX-r.left,my=e.clientY-r.top;
 const py=f(px),[ppx,ppy]=toC(px,py);
 if(Math.sqrt((mx-ppx)**2+(my-ppy)**2)<15)drag=true;
});

c.addEventListener('mousemove',e=>{
 if(drag){
  const r=c.getBoundingClientRect(),[mx]=toM(e.clientX-r.left,e.clientY-r.top);
  px=Math.max(xMin+0.1,Math.min(xMax-0.1,mx));
  draw();
 }
});

c.addEventListener('mouseup',()=>drag=false);
c.addEventListener('mouseleave',()=>drag=false);

document.getElementById('update').addEventListener('click',()=>{
 const fn=parse(document.getElementById('func').value);
 const err=document.getElementById('error');
 if(!fn){err.innerHTML='<div class="error">Invalid function!</div>';return;}
 fs=document.getElementById('func').value;
 f=fn;
 xMin=parseFloat(document.getElementById('xmin').value);
 xMax=parseFloat(document.getElementById('xmax').value);
 if(!calcY()){err.innerHTML='<div class="error">Y-range too large!</div>';return;}
 err.innerHTML='';
 px=Math.min(Math.max(px,xMin+0.1),xMax-0.1);
 calcPos();
 draw();
});

calcY();calcPos();draw();
    </script>
</body>
</html>